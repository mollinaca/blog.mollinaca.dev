<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>競プロ on mollinaca:/dev/random</title>
    <link>https://blog.mollinaca.dev/tags/%E7%AB%B6%E3%83%97%E3%83%AD/</link>
    <description>Recent content in 競プロ on mollinaca:/dev/random</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <lastBuildDate>Sun, 25 Jul 2021 23:00:00 +0900</lastBuildDate><atom:link href="https://blog.mollinaca.dev/tags/%E7%AB%B6%E3%83%97%E3%83%AD/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ベルマンフォード その1</title>
      <link>https://blog.mollinaca.dev/posts/20210725/bellmanford/</link>
      <pubDate>Sun, 25 Jul 2021 23:00:00 +0900</pubDate>
      
      <guid>https://blog.mollinaca.dev/posts/20210725/bellmanford/</guid>
      <description>ベルマンフォードを実装する その(1) 概要 ベルマンフォードは、グラフアルゴリズムにおいて 任意の2点間の最短経路 を求めるアルゴリズムである。 以下の場合に利用ができる。 DAG(有効グラフかつ閉路をもたない)である 負のコストがあってもOK また、負の</description>
    </item>
    
    <item>
      <title>DFS と BFS の例題を解く</title>
      <link>https://blog.mollinaca.dev/posts/20210709/dfs_bfs2/</link>
      <pubDate>Fri, 09 Jul 2021 23:00:00 +0900</pubDate>
      
      <guid>https://blog.mollinaca.dev/posts/20210709/dfs_bfs2/</guid>
      <description>A - 深さ優先探索 次の問題を解く。A - 深さ優先探索 実装 H,W = map(int,input().split()) grid = [list(input()) for i in range(H)] # スタート地点を探す found = False for y,line in enumerate(grid): for x,p in enumerate(line): if p == &amp;#34;s&amp;#34;: start = (y,x) found = True break if found: break from collections import deque q = deque() q.append(start) direction = [[-1,0],[1,0],[0,-1],[0,1]] while q: p = q.pop() # DFS y = p[0] x = p[1] for d in direction: ny = y + d[0] nx = x + d[1] if 0 &amp;lt;= ny &amp;lt; H and 0 &amp;lt;= nx &amp;lt;</description>
    </item>
    
    <item>
      <title>DFS と BFS</title>
      <link>https://blog.mollinaca.dev/posts/20210707/dfs_bfs/</link>
      <pubDate>Wed, 07 Jul 2021 23:00:00 +0900</pubDate>
      
      <guid>https://blog.mollinaca.dev/posts/20210707/dfs_bfs/</guid>
      <description>グラフを取得できたら、深さ優先探索（DFS）と幅優先探索（BFS）を実装してみる。 問題1 入力するグラフは以下。よくあるやつ。 これをテキスト情報で入力にすると以下のようになる。 7 6 1 2 1 3 2 4 2 5 3 6 3 7 このグラフに対して、1から出発して7に</description>
    </item>
    
    <item>
      <title>python でのグラフの取得方法(2)</title>
      <link>https://blog.mollinaca.dev/posts/20210706/graph2/</link>
      <pubDate>Tue, 06 Jul 2021 23:00:00 +0900</pubDate>
      
      <guid>https://blog.mollinaca.dev/posts/20210706/graph2/</guid>
      <description>隣接辞書 これは自分のオリジナル（？）。 オリジナル、というほどのアイデアでもないだろうけど、当初自分がグラフの問題を初めてみて、どうやってこの情報を管理したらいいんだろ？で最初に考えたやりかた。以下のようにグラフ情報をdictで取得する。 この</description>
    </item>
    
    <item>
      <title>python でのグラフの取得方法</title>
      <link>https://blog.mollinaca.dev/posts/20210705/graph/</link>
      <pubDate>Mon, 05 Jul 2021 23:00:00 +0900</pubDate>
      
      <guid>https://blog.mollinaca.dev/posts/20210705/graph/</guid>
      <description>python でグラフの入力を受け取る 昨日のABC208のD問題が解けなかったのが悔しかったので、ちゃんとグラフ問題の解き方を勉強する。具体的には、 今雰囲気でやってるグラフ情報の取得と扱いをちゃんと学習する DFS/BFS の復習 最短経路問題等、典型問題とアルゴリズム</description>
    </item>
    
  </channel>
</rss>
